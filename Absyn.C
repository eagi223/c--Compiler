//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   Prog    ********************/
Prog::Prog(ListFunction *p1)
{
  listfunction_ = p1;

}

Prog::Prog(const Prog & other)
{
  listfunction_ = other.listfunction_->clone();

}

Prog &Prog::operator=(const Prog & other)
{
  Prog tmp(other);
  swap(tmp);
  return *this;
}

void Prog::swap(Prog & other)
{
  std::swap(listfunction_, other.listfunction_);

}

Prog::~Prog()
{
  delete(listfunction_);

}

void Prog::accept(Visitor *v)
{
  v->visitProg(this);
}

Prog *Prog::clone() const
{
  return new Prog(*this);
}



/********************   Fun    ********************/
Fun::Fun(Type *p1, Ident p2, ListDecl *p3, ListStm *p4)
{
  type_ = p1;
  ident_ = p2;
  listdecl_ = p3;
  liststm_ = p4;

}

Fun::Fun(const Fun & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listdecl_ = other.listdecl_->clone();
  liststm_ = other.liststm_->clone();

}

Fun &Fun::operator=(const Fun & other)
{
  Fun tmp(other);
  swap(tmp);
  return *this;
}

void Fun::swap(Fun & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listdecl_, other.listdecl_);
  std::swap(liststm_, other.liststm_);

}

Fun::~Fun()
{
  delete(type_);
  delete(listdecl_);
  delete(liststm_);

}

void Fun::accept(Visitor *v)
{
  v->visitFun(this);
}

Fun *Fun::clone() const
{
  return new Fun(*this);
}



/********************   Dec    ********************/
Dec::Dec(Type *p1, ListIdent *p2)
{
  type_ = p1;
  listident_ = p2;

}

Dec::Dec(const Dec & other)
{
  type_ = other.type_->clone();
  listident_ = other.listident_->clone();

}

Dec &Dec::operator=(const Dec & other)
{
  Dec tmp(other);
  swap(tmp);
  return *this;
}

void Dec::swap(Dec & other)
{
  std::swap(type_, other.type_);
  std::swap(listident_, other.listident_);

}

Dec::~Dec()
{
  delete(type_);
  delete(listident_);

}

void Dec::accept(Visitor *v)
{
  v->visitDec(this);
}

Dec *Dec::clone() const
{
  return new Dec(*this);
}



/********************   SDecl    ********************/
SDecl::SDecl(Decl *p1)
{
  decl_ = p1;

}

SDecl::SDecl(const SDecl & other)
{
  decl_ = other.decl_->clone();

}

SDecl &SDecl::operator=(const SDecl & other)
{
  SDecl tmp(other);
  swap(tmp);
  return *this;
}

void SDecl::swap(SDecl & other)
{
  std::swap(decl_, other.decl_);

}

SDecl::~SDecl()
{
  delete(decl_);

}

void SDecl::accept(Visitor *v)
{
  v->visitSDecl(this);
}

SDecl *SDecl::clone() const
{
  return new SDecl(*this);
}



/********************   SExp    ********************/
SExp::SExp(Exp *p1)
{
  exp_ = p1;

}

SExp::SExp(const SExp & other)
{
  exp_ = other.exp_->clone();

}

SExp &SExp::operator=(const SExp & other)
{
  SExp tmp(other);
  swap(tmp);
  return *this;
}

void SExp::swap(SExp & other)
{
  std::swap(exp_, other.exp_);

}

SExp::~SExp()
{
  delete(exp_);

}

void SExp::accept(Visitor *v)
{
  v->visitSExp(this);
}

SExp *SExp::clone() const
{
  return new SExp(*this);
}



/********************   SBlock    ********************/
SBlock::SBlock(ListStm *p1)
{
  liststm_ = p1;

}

SBlock::SBlock(const SBlock & other)
{
  liststm_ = other.liststm_->clone();

}

SBlock &SBlock::operator=(const SBlock & other)
{
  SBlock tmp(other);
  swap(tmp);
  return *this;
}

void SBlock::swap(SBlock & other)
{
  std::swap(liststm_, other.liststm_);

}

SBlock::~SBlock()
{
  delete(liststm_);

}

void SBlock::accept(Visitor *v)
{
  v->visitSBlock(this);
}

SBlock *SBlock::clone() const
{
  return new SBlock(*this);
}



/********************   SWhile    ********************/
SWhile::SWhile(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

SWhile::SWhile(const SWhile & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SWhile &SWhile::operator=(const SWhile & other)
{
  SWhile tmp(other);
  swap(tmp);
  return *this;
}

void SWhile::swap(SWhile & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SWhile::~SWhile()
{
  delete(exp_);
  delete(stm_);

}

void SWhile::accept(Visitor *v)
{
  v->visitSWhile(this);
}

SWhile *SWhile::clone() const
{
  return new SWhile(*this);
}



/********************   SIf    ********************/
SIf::SIf(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

SIf::SIf(const SIf & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SIf &SIf::operator=(const SIf & other)
{
  SIf tmp(other);
  swap(tmp);
  return *this;
}

void SIf::swap(SIf & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SIf::~SIf()
{
  delete(exp_);
  delete(stm_);

}

void SIf::accept(Visitor *v)
{
  v->visitSIf(this);
}

SIf *SIf::clone() const
{
  return new SIf(*this);
}



/********************   SDo    ********************/
SDo::SDo(Stm *p1, Exp *p2)
{
  stm_ = p1;
  exp_ = p2;

}

SDo::SDo(const SDo & other)
{
  stm_ = other.stm_->clone();
  exp_ = other.exp_->clone();

}

SDo &SDo::operator=(const SDo & other)
{
  SDo tmp(other);
  swap(tmp);
  return *this;
}

void SDo::swap(SDo & other)
{
  std::swap(stm_, other.stm_);
  std::swap(exp_, other.exp_);

}

SDo::~SDo()
{
  delete(stm_);
  delete(exp_);

}

void SDo::accept(Visitor *v)
{
  v->visitSDo(this);
}

SDo *SDo::clone() const
{
  return new SDo(*this);
}



/********************   SIfElse    ********************/
SIfElse::SIfElse(Exp *p1, Stm *p2, Stm *p3)
{
  exp_ = p1;
  stm_1 = p2;
  stm_2 = p3;

}

SIfElse::SIfElse(const SIfElse & other)
{
  exp_ = other.exp_->clone();
  stm_1 = other.stm_1->clone();
  stm_2 = other.stm_2->clone();

}

SIfElse &SIfElse::operator=(const SIfElse & other)
{
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}

void SIfElse::swap(SIfElse & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_1, other.stm_1);
  std::swap(stm_2, other.stm_2);

}

SIfElse::~SIfElse()
{
  delete(exp_);
  delete(stm_1);
  delete(stm_2);

}

void SIfElse::accept(Visitor *v)
{
  v->visitSIfElse(this);
}

SIfElse *SIfElse::clone() const
{
  return new SIfElse(*this);
}



/********************   SFor2    ********************/
SFor2::SFor2(Exp *p1, Exp *p2, Stm *p3)
{
  exp_1 = p1;
  exp_2 = p2;
  stm_ = p3;

}

SFor2::SFor2(const SFor2 & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  stm_ = other.stm_->clone();

}

SFor2 &SFor2::operator=(const SFor2 & other)
{
  SFor2 tmp(other);
  swap(tmp);
  return *this;
}

void SFor2::swap(SFor2 & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(stm_, other.stm_);

}

SFor2::~SFor2()
{
  delete(exp_1);
  delete(exp_2);
  delete(stm_);

}

void SFor2::accept(Visitor *v)
{
  v->visitSFor2(this);
}

SFor2 *SFor2::clone() const
{
  return new SFor2(*this);
}



/********************   SFor3    ********************/
SFor3::SFor3(Exp *p1, Exp *p2, Exp *p3, Stm *p4)
{
  exp_1 = p1;
  exp_2 = p2;
  exp_3 = p3;
  stm_ = p4;

}

SFor3::SFor3(const SFor3 & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  exp_3 = other.exp_3->clone();
  stm_ = other.stm_->clone();

}

SFor3 &SFor3::operator=(const SFor3 & other)
{
  SFor3 tmp(other);
  swap(tmp);
  return *this;
}

void SFor3::swap(SFor3 & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(exp_3, other.exp_3);
  std::swap(stm_, other.stm_);

}

SFor3::~SFor3()
{
  delete(exp_1);
  delete(exp_2);
  delete(exp_3);
  delete(stm_);

}

void SFor3::accept(Visitor *v)
{
  v->visitSFor3(this);
}

SFor3 *SFor3::clone() const
{
  return new SFor3(*this);
}



/********************   SReturn    ********************/
SReturn::SReturn(Exp *p1)
{
  exp_ = p1;

}

SReturn::SReturn(const SReturn & other)
{
  exp_ = other.exp_->clone();

}

SReturn &SReturn::operator=(const SReturn & other)
{
  SReturn tmp(other);
  swap(tmp);
  return *this;
}

void SReturn::swap(SReturn & other)
{
  std::swap(exp_, other.exp_);

}

SReturn::~SReturn()
{
  delete(exp_);

}

void SReturn::accept(Visitor *v)
{
  v->visitSReturn(this);
}

SReturn *SReturn::clone() const
{
  return new SReturn(*this);
}



/********************   EAss    ********************/
EAss::EAss(Ident p1, Exp *p2)
{
  ident_ = p1;
  exp_ = p2;

}

EAss::EAss(const EAss & other)
{
  ident_ = other.ident_;
  exp_ = other.exp_->clone();

}

EAss &EAss::operator=(const EAss & other)
{
  EAss tmp(other);
  swap(tmp);
  return *this;
}

void EAss::swap(EAss & other)
{
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);

}

EAss::~EAss()
{
  delete(exp_);

}

void EAss::accept(Visitor *v)
{
  v->visitEAss(this);
}

EAss *EAss::clone() const
{
  return new EAss(*this);
}



/********************   ELt    ********************/
ELt::ELt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELt::ELt(const ELt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELt &ELt::operator=(const ELt & other)
{
  ELt tmp(other);
  swap(tmp);
  return *this;
}

void ELt::swap(ELt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELt::~ELt()
{
  delete(exp_1);
  delete(exp_2);

}

void ELt::accept(Visitor *v)
{
  v->visitELt(this);
}

ELt *ELt::clone() const
{
  return new ELt(*this);
}



/********************   EGt    ********************/
EGt::EGt(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGt::EGt(const EGt & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGt &EGt::operator=(const EGt & other)
{
  EGt tmp(other);
  swap(tmp);
  return *this;
}

void EGt::swap(EGt & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGt::~EGt()
{
  delete(exp_1);
  delete(exp_2);

}

void EGt::accept(Visitor *v)
{
  v->visitEGt(this);
}

EGt *EGt::clone() const
{
  return new EGt(*this);
}



/********************   EEq    ********************/
EEq::EEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEq::EEq(const EEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEq::~EEq()
{
  delete(exp_1);
  delete(exp_2);

}

void EEq::accept(Visitor *v)
{
  v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   EInc    ********************/
EInc::EInc(Exp *p1)
{
  exp_ = p1;

}

EInc::EInc(const EInc & other)
{
  exp_ = other.exp_->clone();

}

EInc &EInc::operator=(const EInc & other)
{
  EInc tmp(other);
  swap(tmp);
  return *this;
}

void EInc::swap(EInc & other)
{
  std::swap(exp_, other.exp_);

}

EInc::~EInc()
{
  delete(exp_);

}

void EInc::accept(Visitor *v)
{
  v->visitEInc(this);
}

EInc *EInc::clone() const
{
  return new EInc(*this);
}



/********************   EDec    ********************/
EDec::EDec(Exp *p1)
{
  exp_ = p1;

}

EDec::EDec(const EDec & other)
{
  exp_ = other.exp_->clone();

}

EDec &EDec::operator=(const EDec & other)
{
  EDec tmp(other);
  swap(tmp);
  return *this;
}

void EDec::swap(EDec & other)
{
  std::swap(exp_, other.exp_);

}

EDec::~EDec()
{
  delete(exp_);

}

void EDec::accept(Visitor *v)
{
  v->visitEDec(this);
}

EDec *EDec::clone() const
{
  return new EDec(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   Call    ********************/
Call::Call(Ident p1, ListExp *p2)
{
  ident_ = p1;
  listexp_ = p2;

}

Call::Call(const Call & other)
{
  ident_ = other.ident_;
  listexp_ = other.listexp_->clone();

}

Call &Call::operator=(const Call & other)
{
  Call tmp(other);
  swap(tmp);
  return *this;
}

void Call::swap(Call & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexp_, other.listexp_);

}

Call::~Call()
{
  delete(listexp_);

}

void Call::accept(Visitor *v)
{
  v->visitCall(this);
}

Call *Call::clone() const
{
  return new Call(*this);
}



/********************   EVar    ********************/
EVar::EVar(Ident p1)
{
  ident_ = p1;

}

EVar::EVar(const EVar & other)
{
  ident_ = other.ident_;

}

EVar &EVar::operator=(const EVar & other)
{
  EVar tmp(other);
  swap(tmp);
  return *this;
}

void EVar::swap(EVar & other)
{
  std::swap(ident_, other.ident_);

}

EVar::~EVar()
{

}

void EVar::accept(Visitor *v)
{
  v->visitEVar(this);
}

EVar *EVar::clone() const
{
  return new EVar(*this);
}



/********************   EStr    ********************/
EStr::EStr(String p1)
{
  string_ = p1;

}

EStr::EStr(const EStr & other)
{
  string_ = other.string_;

}

EStr &EStr::operator=(const EStr & other)
{
  EStr tmp(other);
  swap(tmp);
  return *this;
}

void EStr::swap(EStr & other)
{
  std::swap(string_, other.string_);

}

EStr::~EStr()
{

}

void EStr::accept(Visitor *v)
{
  v->visitEStr(this);
}

EStr *EStr::clone() const
{
  return new EStr(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EDouble    ********************/
EDouble::EDouble(Double p1)
{
  double_ = p1;

}

EDouble::EDouble(const EDouble & other)
{
  double_ = other.double_;

}

EDouble &EDouble::operator=(const EDouble & other)
{
  EDouble tmp(other);
  swap(tmp);
  return *this;
}

void EDouble::swap(EDouble & other)
{
  std::swap(double_, other.double_);

}

EDouble::~EDouble()
{

}

void EDouble::accept(Visitor *v)
{
  v->visitEDouble(this);
}

EDouble *EDouble::clone() const
{
  return new EDouble(*this);
}



/********************   TInt    ********************/
TInt::TInt()
{

}

TInt::TInt(const TInt & other)
{

}

TInt &TInt::operator=(const TInt & other)
{
  TInt tmp(other);
  swap(tmp);
  return *this;
}

void TInt::swap(TInt & other)
{

}

TInt::~TInt()
{

}

void TInt::accept(Visitor *v)
{
  v->visitTInt(this);
}

TInt *TInt::clone() const
{
  return new TInt(*this);
}



/********************   TDouble    ********************/
TDouble::TDouble()
{

}

TDouble::TDouble(const TDouble & other)
{

}

TDouble &TDouble::operator=(const TDouble & other)
{
  TDouble tmp(other);
  swap(tmp);
  return *this;
}

void TDouble::swap(TDouble & other)
{

}

TDouble::~TDouble()
{

}

void TDouble::accept(Visitor *v)
{
  v->visitTDouble(this);
}

TDouble *TDouble::clone() const
{
  return new TDouble(*this);
}




/********************   ListFunction    ********************/

void ListFunction::accept(Visitor *v)
{
  v->visitListFunction(this);
}


ListFunction *ListFunction::clone() const
{
  return new ListFunction(*this);
}


/********************   ListStm    ********************/

void ListStm::accept(Visitor *v)
{
  v->visitListStm(this);
}


ListStm *ListStm::clone() const
{
  return new ListStm(*this);
}


/********************   ListDecl    ********************/

void ListDecl::accept(Visitor *v)
{
  v->visitListDecl(this);
}


ListDecl *ListDecl::clone() const
{
  return new ListDecl(*this);
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}


ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}




